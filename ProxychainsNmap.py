import multiprocessing
import Queue
import threading
import os
import sys
import subprocess
from random import randint

def Execution(Task_queue):
  while True:
    Ip = Task_queue.get()
    # If the queue is emepty exit this proc
    IpName = str(randint(1000,999999999)) + str(".gnmap")

    if Ip is None:
      break
    try:
      print "[*] On Ip: " + Ip
      subprocess.call(["proxychains", "nmap", "-Pn", "-n", "-sT", "--max-scan-delay", "0", "-p111,445,139,21-23,80,443", "-oG", IpName, "--open", Ip])
    except:
      pass

def TaskSelector(Task_queue, verbose=False):
    total_proc = int(2)
    for i in xrange(total_proc):
        Task_queue.put(None)
    procs = []
    for thread in range(total_proc):
        procs.append(multiprocessing.Process(target=Execution, args=(Task_queue,)))
    for p in procs:
        p.daemon = True
        p.start()
    for p in procs:
        p.join()
    Task_queue.close()


def Ip_List(Task_queue):
    items = []
    try:
        with open('iplist.txt', "r") as myfile:
            lines = myfile.readlines()
            for line in lines:
              line = line.rstrip('\n')
              items.append(line)
            for item in items:
              Task_queue.put(item)
            return Task_queue
    except Exception as e:
        print e
        sys.exit(0)

def main():
  Task_queue = multiprocessing.Queue()
  Task_queue = Ip_List(Task_queue)
  TaskSelector(Task_queue)


if __name__ == "__main__":
    try:  
         main()
    except KeyboardInterrupt:
        print 'Interrupted'
        try:
            sys.exit(0)
        except SystemExit:
            os._exit(0)
